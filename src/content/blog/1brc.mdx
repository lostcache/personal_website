---
title: "My Take on the 1ğŸğŸï¸ Challenge"
description: "My attempt at the legendary 1ğŸğŸï¸ challenge. (No CPUs were harmed in the making of this blog post. RAM? Maybe.)"
pubDate: "Dec 16 2025"
---

### Why?

All my life (read: since I was `{current_age_dec_2026 - 2}` years old), Iâ€™ve wanted a job where I could ignore business logic and just make things go _brrrrr_.

The **1 Billion Row Challenge** (1BRC) was the perfect excuse to commit unholy levels of premature optimizationâ€”without crashing production.

So, here we go.

### Attempt 1: The "It Works" Approach

Iâ€™ve learned the hard way like, _really_ hard wayâ€”to start simple.

For Attempt 1, I kept it dead simple. Zero optimization. Just me, raw C++, and a desire to understand the problem components. The best way to do that? Implement the "dumb" version.

**Result:** It runs in **~630s**.

**TODO**: Refactor below code to adhere to SIP and for a better flamegraph

```cpp title="main.cpp"
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <limits.h>
#include <limits>
#include <map>
#include <sstream>
#include <string>

struct LocationStats {
    double min = std::numeric_limits<double>::max();
    double max = std::numeric_limits<double>::lowest();
    double sum = 0;
    int freq = 0;
};

void printResults(const std::map<std::string, LocationStats>& m) {
    std::string outBuffer;
    outBuffer.reserve(8 * 1024 * 1024);

    bool first = true;
    outBuffer += "{";
    for (const auto& [loc, stat] : m) {
        char buf[32];
        if (!first) outBuffer += ", ";
        outBuffer += loc;
        outBuffer += "=";
        std::snprintf(buf, sizeof(buf), "%.1f/%.1f/%.1f", stat.min, stat.sum / stat.freq, stat.max);
        outBuffer += buf;
        first = false;
    }
    outBuffer += "}\n";

    std::cout << outBuffer;
}

std::pair<std::string, double> parseLine(const std::string& line) {
    std::istringstream ss(line);

    std::string location, tempString;
    std::getline(ss, location, ';');
    std::getline(ss, tempString, ';');
    double temperature = std::stod(tempString);

    return {location, temperature};
}

void updateStats(const std::string& location, const double& temperature,
                 std::map<std::string, LocationStats>& m) {
    LocationStats* locationStat = &m[location];
    locationStat->min = std::fmin(locationStat->min, temperature);
    locationStat->max = std::fmax(locationStat->max, temperature);
    locationStat->freq++;
    locationStat->sum += temperature;
}

std::map<std::string, LocationStats> accumulate(std::ifstream& f) {
    std::map<std::string, LocationStats> m;
    std::string tempBuffer;
    while (std::getline(f, tempBuffer)) {
        auto [location, temperature] = parseLine(tempBuffer);
        updateStats(location, temperature, m);
    }
    return m;
}

void oneBrc() {
    std::ifstream f("../data/measurements.txt");

    std::map<std::string, LocationStats> m = accumulate(f);

    printResults(m);
}

int main() {
    oneBrc();

    return EXIT_SUCCESS;
}
```

---

The 2024 version of me would probably just throw standard optimizations at this and hope for the best. But we're doing science here. I want to know exactly _why_ it's taking so long and where the bottleneck lives so we can target our efforts.

Time for a Flamegraph.

If you don't know [Brendan Gregg](https://www.brendangregg.com/index.html), stop reading this and go read [his blog](https://www.brendangregg.com/overview.html). He is practically the patron saint of systems performance.

I used his legendary `flamegraph.pl` toolset (from [his repo](https://github.com/brendangregg/FlameGraph/)) to visualize the stack traces.

```bash title="flamegraph_linux.sh"
rm -f main out.perf perf.data perf.data.old flamegraph.svg

clang++ -std=c++23 -O2 -g -fno-omit-frame-pointer -Werror -Wall -o main main.cpp

# Record stack samples (requires sudo or perf_event_paranoid relaxed)
sudo perf record -F 997 -g -- ./main

# Convert perf data to folded stacks
perf script > out.perf
./stackcollapse-perf.pl out.perf > out.folded

# Generate the flamegraph
./flamegraph.pl out.folded > flamegraph.svg
```

<br />

the graph is interactive, feel free to poke around.

<object
  type="image/svg+xml"
  data="/1brc_sol_1_flamegraph.svg"
  style={{ width: "100%" }}
></object>

### More comming soonish...
