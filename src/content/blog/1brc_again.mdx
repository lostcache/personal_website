---
title: "The 1üêùüèéÔ∏è Challenge in Zig and Rust"
description: "After completing the challenge in cpp I explore the Rust and Zig variations to better understand the language related tradeoffs"
pubDate: "Last Update, Jan 1 2026"
---

import ExpandableCode from "../../components/ExpandableCode.astro";

After completing the challenge in cpp I decide to redo it in **Zig** and **Rust** to better understand the language related subtilities and tradeoffs.

Starting with rust.

I don't have the dumb version of the solution in rust but straight away I notice how easy it is to handle errors in Rust just because you have no other option.

**Result\<...\>** and **Option\<...\>** makes things really elegant. But still rust does a pretty _good job_ at hiding the underlying behaviour like memory allocations.

But upon testing optimized version of a multi-threaded solution that only perfoms a single copy of location strings from underlying buffer of **std::io::BufReader** to the **std::collections::BTreeMap** vs the unoptimized solution of reading from the underlying buffer to a **std::string::String** and then parsing (2 copies), to my surprise the unoptimized solution consistently did ~3 seconds better than the optimized solution and not just that the unoptimized solution is sooo much nicer to read and as a result easier to maintain.

Optimized Code.

<ExpandableCode maxHeight="200px">

```rust
use std::{
    io::{BufRead, Read, Seek},
    thread::JoinHandle,
};

const NUM_THREADS: usize = 8;

struct LocationStats {
    min: i32,
    max: i32,
    sum: i64,
    freq: usize,
}

fn get_file_path() -> std::path::PathBuf {
    let args: std::vec::Vec<String> = std::env::args().collect();
    match args.len() {
        2 => std::path::PathBuf::from(&args[1]),
        _ => std::path::PathBuf::from("../data/measurements.txt"),
    }
}

fn print_result(
    m: &std::collections::BTreeMap<String, LocationStats>,
) -> Result<(), std::io::Error> {
    print!("{{");
    let mut it = m.iter().peekable();
    while let Some((location, stat)) = it.next() {
        let mut avg = stat.sum as f64 / stat.freq as f64 / 10.0;
        avg = (avg * 10.0).round() / 10.0;
        print!(
            "{}={:.1}/{:.1}/{:.1}",
            location,
            stat.min as f64 / 10.0,
            avg,
            stat.max as f64 / 10.0
        );

        if let Some(_) = it.peek() {
            print!(", ");
        }
    }
    print!("}}");

    Ok(())
}

fn parse_line(line: &[u8]) -> Option<(String, i32)> {
    let semicolon_pos = line.iter().position(|&b| b == b';')?;
    let location = &line[..semicolon_pos];
    let temp_bytes = &line[semicolon_pos + 1..];

    if location.is_empty() || temp_bytes.is_empty() {
        return None;
    }

    // Parse temperature from bytes
    let temp_str = std::str::from_utf8(temp_bytes).ok()?.trim();
    let temperature: f64 = temp_str.parse().ok()?;
    let temp_int = (temperature * 10.0).round() as i32;

    // Convert location bytes to String
    let location_str = std::str::from_utf8(location).ok()?.to_string();

    Some((location_str, temp_int))
}

fn update_map(
    main_map: &mut std::collections::BTreeMap<String, LocationStats>,
    batch_map: std::collections::BTreeMap<String, LocationStats>,
) {
    for (location, stats) in batch_map {
        let entry = main_map.entry(location).or_insert(LocationStats {
            min: std::i32::MAX,
            max: std::i32::MIN,
            sum: 0,
            freq: 0,
        });

        entry.min = std::cmp::min(entry.min, stats.min);
        entry.max = std::cmp::max(entry.max, stats.max);
        entry.sum += stats.sum;
        entry.freq += stats.freq;
    }
}

fn update_stats(
    m: &mut std::collections::BTreeMap<String, LocationStats>,
    location: String,
    temperature: i32,
) {
    let entry = m.entry(location).or_insert(LocationStats {
        min: std::i32::MAX,
        max: std::i32::MIN,
        sum: 0,
        freq: 0,
    });
    entry.min = std::cmp::min(entry.min, temperature);
    entry.max = std::cmp::max(entry.max, temperature);
    entry.sum += temperature as i64;
    entry.freq += 1;
}

fn skip_first_line(start: u64, f: &mut std::fs::File) -> u64 {
    assert!(start > 0);

    let mut skipped_bytes = 0u64;
    f.seek(std::io::SeekFrom::Start(start - 1)).unwrap();
    let mut prev_char = [0u8; 1];
    f.read_exact(&mut prev_char).unwrap();

    if prev_char[0] != b'\n' {
        // Skip rest of partial line and count the bytes
        loop {
            let mut byte = [0u8; 1];
            match f.read_exact(&mut byte) {
                Ok(()) => {
                    skipped_bytes += 1;
                    if byte[0] == b'\n' {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    }

    skipped_bytes
}

fn process_batch(
    thread_idx: usize,
    file_path: &std::path::Path,
    start: u64,
    batch_bytes: u64,
) -> std::collections::BTreeMap<String, LocationStats> {
    let mut m = std::collections::BTreeMap::<String, LocationStats>::new();

    let mut f = std::fs::File::open(file_path).unwrap();

    let mut processed_bytes = 0u64;

    if thread_idx == 0 {
        f.seek(std::io::SeekFrom::Start(start)).unwrap();
    } else {
        processed_bytes += skip_first_line(start, &mut f);
    }

    let mut buf_reader = std::io::BufReader::new(f);

    loop {
        if processed_bytes >= batch_bytes {
            break;
        }

        let buf = match buf_reader.fill_buf() {
            Ok(buf) if buf.is_empty() => break, // EOF
            Ok(buf) => buf,
            Err(_) => break,
        };

        let line_end = buf.iter().position(|&b| b == b'\n');

        match line_end {
            Some(pos) => {
                let line = &buf[..pos];
                if !line.is_empty() {
                    if let Some((location, temperature)) = parse_line(line) {
                        update_stats(&mut m, location, temperature);
                    }
                }
                let bytes_consumed = pos + 1;
                buf_reader.consume(bytes_consumed);
                processed_bytes += bytes_consumed as u64;
            }
            // No newline
            //      case 1: when internal buffer ends with a line split
            //      case 2: EOF
            // just call read_until directly, it'll handle the buffer internally
            None => {
                let mut line_buf = Vec::new();

                match buf_reader.read_until(b'\n', &mut line_buf) {
                    Ok(0) | Ok(_) if line_buf.is_empty() => break,
                    Ok(n) => {
                        let line = if line_buf.ends_with(&[b'\n']) {
                            &line_buf[..line_buf.len() - 1]
                        } else {
                            &line_buf[..]
                        };

                        if !line.is_empty() {
                            if let Some((location, temperature)) = parse_line(line) {
                                update_stats(&mut m, location, temperature);
                            }
                        }

                        processed_bytes += n as u64;
                    }
                    Err(_) => break,
                }
            }
        }
    }

    m
}

fn process_in_batches(
    file_path: &std::path::Path,
    file_size: u64,
) -> std::collections::BTreeMap<String, LocationStats> {
    let batch_size = (file_size + NUM_THREADS as u64 - 1) / NUM_THREADS as u64;
    let mut handles: std::vec::Vec<JoinHandle<std::collections::BTreeMap<String, LocationStats>>> =
        Vec::with_capacity(NUM_THREADS);

    for i in 0..NUM_THREADS {
        let start = i as u64 * batch_size;
        let path = file_path.to_path_buf();

        handles.push(std::thread::spawn(move || {
            process_batch(i, &path, start, batch_size)
        }));
    }

    let mut m = std::collections::BTreeMap::<String, LocationStats>::new();
    for handle in handles {
        let batch_map = handle.join().unwrap();
        update_map(&mut m, batch_map);
    }

    m
}

fn process_in_single_batch(
    file_path: &std::path::Path,
    file_size: u64,
) -> std::collections::BTreeMap<String, LocationStats> {
    process_batch(0, file_path, 0, file_size)
}

fn process(file_path: &std::path::Path) -> std::collections::BTreeMap<String, LocationStats> {
    let f = std::fs::File::open(file_path).unwrap();
    let file_size = f.metadata().unwrap().len();

    if file_size > 4 * 1024 {
        process_in_batches(file_path, file_size)
    } else {
        process_in_single_batch(file_path, file_size)
    }
}

fn main() {
    let file_path = get_file_path();

    let m = process(&file_path);

    print_result(&m).unwrap();
}
```

</ExpandableCode>

Unoptimized Code.

<ExpandableCode maxHeight="200px">

```rust
use std::{
    io::{BufRead, Read, Seek},
    thread::JoinHandle,
};

const NUM_THREADS: usize = 8;

struct LocationStats {
    min: i32,
    max: i32,
    sum: i64,
    freq: usize,
}

fn get_file_path() -> std::path::PathBuf {
    let args: std::vec::Vec<String> = std::env::args().collect();
    match args.len() {
        2 => std::path::PathBuf::from(&args[1]),
        _ => std::path::PathBuf::from("../data/measurements.txt"),
    }
}

fn print_result(
    m: &std::collections::BTreeMap<String, LocationStats>,
) -> Result<(), std::io::Error> {
    print!("{{");
    let mut it = m.iter().peekable();
    while let Some((location, stat)) = it.next() {
        let mut avg = stat.sum as f64 / stat.freq as f64 / 10.0;
        avg = (avg * 10.0).round() / 10.0;
        print!(
            "{}={:.1}/{:.1}/{:.1}",
            location,
            stat.min as f64 / 10.0,
            avg,
            stat.max as f64 / 10.0
        );

        if let Some(_) = it.peek() {
            print!(", ");
        }
    }
    print!("}}");

    Ok(())
}

fn parse_line(line: &str) -> Option<(String, i32)> {
    let line = line.trim();
    if line.is_empty() {
        return None;
    }

    let semicolon_pos = line.find(';')?;
    let location = &line[..semicolon_pos];
    let temp_str = &line[semicolon_pos + 1..];

    if location.is_empty() || temp_str.is_empty() {
        return None;
    }

    let temperature: f64 = temp_str.parse().ok()?;
    let temp_int = (temperature * 10.0).round() as i32;

    let location_str = location.to_string();

    Some((location_str, temp_int))
}

fn update_map(
    main_map: &mut std::collections::BTreeMap<String, LocationStats>,
    batch_map: std::collections::BTreeMap<String, LocationStats>,
) {
    for (location, stats) in batch_map {
        let entry = main_map.entry(location).or_insert(LocationStats {
            min: std::i32::MAX,
            max: std::i32::MIN,
            sum: 0,
            freq: 0,
        });

        entry.min = std::cmp::min(entry.min, stats.min);
        entry.max = std::cmp::max(entry.max, stats.max);
        entry.sum += stats.sum;
        entry.freq += stats.freq;
    }
}

fn update_stats(
    m: &mut std::collections::BTreeMap<String, LocationStats>,
    location: String,
    temperature: i32,
) {
    let entry = m.entry(location).or_insert(LocationStats {
        min: std::i32::MAX,
        max: std::i32::MIN,
        sum: 0,
        freq: 0,
    });
    entry.min = std::cmp::min(entry.min, temperature);
    entry.max = std::cmp::max(entry.max, temperature);
    entry.sum += temperature as i64;
    entry.freq += 1;
}

fn skip_first_line(start: u64, fp: &std::path::Path) -> u64 {
    assert!(start > 0);

    let mut skipped_bytes = 0u64;

    let mut f = std::fs::File::open(fp).unwrap();

    f.seek(std::io::SeekFrom::Start(start - 1)).unwrap();
    let mut prev_char = [0u8; 1];
    f.read_exact(&mut prev_char).unwrap();

    if prev_char[0] != b'\n' {
        let mut buf_reader = std::io::BufReader::new(f);
        let mut buf = std::string::String::with_capacity(128);
        skipped_bytes += buf_reader.read_line(&mut buf).unwrap() as u64;
    }

    skipped_bytes
}

fn process_batch(
    thread_idx: usize,
    file_path: &std::path::Path,
    start: u64,
    batch_bytes: u64,
) -> std::collections::BTreeMap<String, LocationStats> {
    let mut f = std::fs::File::open(file_path).unwrap();

    let mut processed_bytes = 0u64;

    if thread_idx == 0 {
        f.seek(std::io::SeekFrom::Start(start)).unwrap();
    } else {
        processed_bytes += skip_first_line(start, file_path);
        f.seek(std::io::SeekFrom::Start(start + processed_bytes))
            .unwrap();
    }

    let mut buf_reader = std::io::BufReader::new(f);
    let mut m = std::collections::BTreeMap::<String, LocationStats>::new();
    let mut line = std::string::String::with_capacity(128);

    loop {
        if processed_bytes >= batch_bytes {
            break;
        }

        line.clear();
        let bytes_read = buf_reader.read_line(&mut line).unwrap() as u64;
        if bytes_read == 0 {
            break; // EOF
        }

        processed_bytes += bytes_read;

        if let Some((location, temperature)) = parse_line(&line) {
            update_stats(&mut m, location, temperature);
        }
    }

    m
}

fn process_in_batches(
    file_path: &std::path::Path,
    file_size: u64,
) -> std::collections::BTreeMap<String, LocationStats> {
    let batch_size = (file_size + NUM_THREADS as u64 - 1) / NUM_THREADS as u64;
    let mut handles: std::vec::Vec<JoinHandle<std::collections::BTreeMap<String, LocationStats>>> =
        Vec::with_capacity(NUM_THREADS);

    for i in 0..NUM_THREADS {
        let start = i as u64 * batch_size;
        let path = file_path.to_path_buf();

        handles.push(std::thread::spawn(move || {
            process_batch(i, &path, start, batch_size)
        }));
    }

    let mut m = std::collections::BTreeMap::<String, LocationStats>::new();
    for handle in handles {
        let batch_map = handle.join().unwrap();
        update_map(&mut m, batch_map);
    }

    m
}

fn process_in_single_batch(
    file_path: &std::path::Path,
    file_size: u64,
) -> std::collections::BTreeMap<String, LocationStats> {
    process_batch(0, file_path, 0, file_size)
}

fn process(file_path: &std::path::Path) -> std::collections::BTreeMap<String, LocationStats> {
    let f = std::fs::File::open(file_path).unwrap();
    let file_size = f.metadata().unwrap().len();

    if file_size > 4 * 1024 {
        process_in_batches(file_path, file_size)
    } else {
        process_in_single_batch(file_path, file_size)
    }
}

fn main() {
    let file_path = get_file_path();

    let m = process(&file_path);

    print_result(&m).unwrap();
}
```

</ExpandableCode>

I understand that the optimised version can me made cleaner but it is an absolute nightmare to refactor because of rust's ownership and borrow rules.

Additionally, I was using **std::str::from_utf8** to convert location slice to owned String struct and if you read the docs it mention **std::std::from_utf8_unchecked** which if which you can use withing **unsafe\{...\}** blocks, I tried with both versions and the unsafe version did save me some time but only ~2% if i'm being generous. Honestly I think this type of optimizations depend on the context so I'm okay with the unsafe version.

I wasn't expecting these behaviour from rust, I am pleasantly surprised, so my somewhat educated guess is that writing maintainable code and letting the compiler handle the optimization really pays off while using rust, at least for this workload. Nice.

Final Version

<ExpandableCode maxHeight="200px">
```rust
const NUM_THREADS: usize = 8;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
struct LocationEntry {
location: String,
min: i32,
max: i32,
sum: i64,
freq: usize,
}

impl LocationEntry {
pub fn new() -> Self {
Self {
location: std::string::String::new(),
min: std::i32::MAX,
max: std::i32::MIN,
sum: 0,
freq: 0,
}
}
}

struct FastMap {
data: std::vec::Vec<LocationEntry>,
mask: usize,
}

impl FastMap {
fn hash(&self, key: &[u8]) -> usize {
let mut hash = 0 as usize;

        for ch in key {
            hash = hash * 1315423911 as usize + *ch as usize;
        }
        hash
    }

    fn get_idx(&self, key: &[u8]) -> usize {
        let hash = self.hash(key);
        let mut idx = hash & self.mask;
        loop {
            let location = &self.data[idx].location;
            if location.len() <= 0 || location.as_bytes() == key {
                return idx;
            }
            idx = (idx + 1) & self.mask;
        }
    }

    fn sort_inplace(&mut self) {
        self.data.sort();
    }

    pub fn update(&mut self, location: &[u8], temperature: i32) {
        let idx = self.get_idx(location);

        if self.data[idx].location.len() <= 0 {
            self.data[idx].location = unsafe { std::str::from_utf8_unchecked(location).to_string() }
        }
        self.data[idx].freq += 1;
        self.data[idx].sum += temperature as i64;
        self.data[idx].min = std::cmp::min(self.data[idx].min, temperature);
        self.data[idx].max = std::cmp::max(self.data[idx].max, temperature);
    }

    pub fn update_batch(&mut self, other: &Self) {
        for i in 0..other.data.len() {
            let other_location = &other.data[i].location;

            if other_location.len() <= 0 {
                continue;
            }

            let this_idx = self.get_idx(other_location.as_bytes());

            if self.data[this_idx].location.len() <= 0 {
                self.data[this_idx].location = other_location.to_string();
            }
            self.data[this_idx].freq += other.data[i].freq;
            self.data[this_idx].sum += other.data[i].sum;
            self.data[this_idx].min = std::cmp::min(self.data[this_idx].min, other.data[i].min);
            self.data[this_idx].max = std::cmp::max(self.data[this_idx].max, other.data[i].max);
        }
    }

    pub fn print_sorted(&mut self) {
        self.sort_inplace();

        let mut it = self.data.iter().peekable();

        print!("{{");
        while let Some(location_entry) = it.next() {
            let location = &location_entry.location;

            if location.len() <= 0 {
                continue;
            }

            let mut avg = location_entry.sum as f64 / location_entry.freq as f64 / 10.0;
            avg = (avg * 10.0).round() / 10.0;
            print!(
                "{}={:.1}/{:.1}/{:.1}",
                location,
                location_entry.min as f64 / 10.0,
                avg,
                location_entry.max as f64 / 10.0
            );

            if let Some(_) = it.peek() {
                print!(", ");
            }
        }
        print!("}}");
    }

    pub fn new() -> Self {
        Self {
            data: vec![LocationEntry::new(); 1 << 14],
            mask: (1 << 14) - 1,
        }
    }

}

fn get*file_path() -> std::path::PathBuf {
let args: std::vec::Vec<String> = std::env::args().collect();
match args.len() {
2 => std::path::PathBuf::from(&args[1]),
* => std::path::PathBuf::from("../data/measurements.txt"),
}
}

fn skip_first_line(start: u64, mmap_f: &[u8]) -> u64 {
assert!(start > 0);

    let prev_char = mmap_f[(start - 1) as usize];

    if prev_char == b'\n' {
        return 0;
    }

    let mut new_line_char_pos = start as usize;
    loop {
        if new_line_char_pos >= mmap_f.len() || mmap_f[new_line_char_pos] == b'\n' {
            break;
        }
        new_line_char_pos += 1;
    }

    new_line_char_pos as u64 - start + 1

}

fn parse_i32_from_byte_slice(slice: &[u8]) -> i32 {
let mut pos = 0 as usize;
let is_negative = if slice[0] == b'-' {
pos += 1;
true
} else {
false
};

    let num = if slice[pos + 1] == b'.' {
        (slice[pos] - b'0') as i32 * 10 + (slice[pos + 2] - b'0') as i32
    } else {
        (slice[pos] - b'0') as i32 * 100
            + (slice[pos + 1] - b'0') as i32 * 10
            + (slice[pos + 3] - b'0') as i32
    };

    if is_negative {
        -num
    } else {
        num
    }

}

fn parse_line(line: &[u8]) -> Option<(&[u8], i32)> {
if line.is_empty() {
return None;
}

    let mut semicol_pos = 0 as usize;
    loop {
        if line[semicol_pos] == b';' {
            break;
        }
        semicol_pos += 1;
    }

    let location = &line[..semicol_pos];
    let temperature_slice = &line[semicol_pos + 1..];

    if location.is_empty() || temperature_slice.is_empty() {
        return None;
    }

    // saves ~3s in ~34s total runtime.
    let temperature = parse_i32_from_byte_slice(temperature_slice);

    Some((location, temperature))

}

fn process_batch(thread_idx: usize, mmap_f: &[u8], start: u64, batch_bytes: u64) -> FastMap {
let mut processed_bytes = 0 as u64;

    if thread_idx != 0 {
        processed_bytes += skip_first_line(start, mmap_f);
    }

    let mut m = FastMap::new();

    loop {
        if processed_bytes >= batch_bytes {
            break;
        }

        let line_start = (start + processed_bytes) as usize;
        if line_start >= mmap_f.len() {
            break;
        }

        let mut new_line_char_pos = start + processed_bytes;
        loop {
            if new_line_char_pos as usize >= mmap_f.len()
                || mmap_f[new_line_char_pos as usize] == b'\n'
            {
                break;
            }
            new_line_char_pos += 1;
        }

        let line_end = new_line_char_pos as usize;
        if let Some((location, temperature)) = parse_line(&mmap_f[line_start..line_end]) {
            m.update(location, temperature);
        }

        processed_bytes += (line_end - line_start + 1) as u64;
    }

    m

}

fn process_in_batches(file_path: &std::path::Path, file_size: u64) -> FastMap {
// Create mmap once and share it across all threads
let f = std::fs::File::open(file_path).unwrap();
let mmap_f = unsafe { memmap2::Mmap::map(&f).unwrap() };
let mmap_arc = std::sync::Arc::new(mmap_f);

    let batch_size = (file_size + NUM_THREADS as u64 - 1) / NUM_THREADS as u64;
    let mut handles: std::vec::Vec<std::thread::JoinHandle<FastMap>> =
        Vec::with_capacity(NUM_THREADS);

    for i in 0..NUM_THREADS {
        let start = i as u64 * batch_size;
        let mmap_clone = mmap_arc.clone();

        handles.push(std::thread::spawn(move || {
            process_batch(i, &mmap_clone, start, batch_size)
        }));
    }

    let mut m = FastMap::new();
    for handle in handles {
        let batch_map = handle.join().unwrap();
        m.update_batch(&batch_map);
    }

    m

}

fn process_in_single_batch(file_path: &std::path::Path, file_size: u64) -> FastMap {
let f = std::fs::File::open(file_path).unwrap();
let mmap_f = unsafe { memmap2::Mmap::map(&f).unwrap() };
process_batch(0, &mmap_f, 0, file_size)
}

fn process(file_path: &std::path::Path) -> FastMap {
let f = std::fs::File::open(file_path).unwrap();
let file_size = f.metadata().unwrap().len();

    if file_size > 4 * 1024 {
        process_in_batches(file_path, file_size)
    } else {
        process_in_single_batch(file_path, file_size)
    }

}

fn main() {
let file_path = get_file_path();

    let mut m = process(&file_path);

    m.print_sorted();

}

````

</ ExpandableCode>


```sh
Time (mean ¬± œÉ):     32.062 s ¬±  0.048 s    [User: 78.749 s, System: 12.305 s]
Range (min ‚Ä¶ max):   31.996 s ‚Ä¶ 32.126 s    10 runs

````

### Zig (my favorite) OTW...
